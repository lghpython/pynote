## 动态规划- dynamic programming

####  1. 原问题分为简单的子问题

#### 2. 列表存储子问题题解

#### 3. 子问题题解复用得出后续的解,最终得出结果

#### 4. 使用条件子问题的解环环相扣,由以得出子问题的解可以得出后续的解

## 题目一: leetcode-[95]不同的二叉搜索树 II.py

### 1.  二叉搜索树是什么?

- BST----Binary Search Tree
- 左子树≤根  , 右子树≥根

### 2. 结果为[1,n] 组成的不同结构的二叉搜索树个数

- i 的二叉搜索树个数G(i)
- k为当k为二叉搜索树的根节点时的二叉搜索树个数F(i,n)
- 得出公式

$$
G(n)=\sum_{i=1}^{n}F(i,n)
$$

$$
F(i,n) = G(i-1)*G(n-i)
$$

- 所以得出G(n)需要,G(0)到G(n-1)可以得出
- 由简单的G(0) = 1 和G(1) = 1 可以推出G(2)的值,逐步后推得到G(n)的值

#### 代码实现

```python
# 二叉搜索树
# 给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。 
# 
#  示例： 
# 
#  输入：3
# 输出：
# [
#   [1,null,3,2],
#   [3,2,null,1],
#   [3,1,null,null,2],
#   [2,1,3],
#   [1,null,2,null,3]
# ]
# 解释：
# 以上的输出对应以下 5 种不同结构的二叉搜索树：
# 
#    1         3     3      2      1
#     \       /     /      / \      \
#      3     2     1      1   3      2
#     /     /       \                 \
#    2     1         2                 3
#  
# 动态规划代码实现
class Solution:
    def numTrees(self, n: int) -> int:
        # 解法一: 动态规划, 结果dp[n] 计算需要用到 dp[0]...dp[n] 
        dp = [0]*(n+1)
        # 从简单的dp[0] dp[1] 作为前提条件,dp[2] = dp[0]*dp[1]+dp[1]*dp[0]..
        dp[0],dp[1] = 1,1
        # 分解子问题, 子问题的解存储复用
        for i in range(2,n+1):
            for k in range(1,i+1):
                dp[i] += dp[i-k] * dp[k-1]
        return dp[n]
```

## 题目二: leetcode-[70]爬楼梯

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
>
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> 注意：给定 n 是一个正整数。
>
> 示例 1：
>
> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶
> 2.  2 阶
> 示例 2：
>
> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶 + 1 阶
> 2.  1 阶 + 2 阶
> 3.  2 阶 + 1 阶
>

### 解题思路-动态规划

- dp[n] 表示爬 n 阶楼梯的所有可能数
- dp[0] = 1  dp[1] = 1
- dp[i] = dp[i-1] + dp[i-2]
  - 其中dp[i-1] 表示当前为1的可能数
  - dp[i-2]表示当前为2 的可能数
- 结果等同于斐波那契数列推导

```python
class Solution:
    def climbStairs(self, n) -> int:
        dp = [0]* (n+1)
        dp[0], dp[1] = 1, 1
        for i in range(2,n+1):
            dp[i] = dp[i-1]+dp[i-2]
        return dp[n]
      
class Solution:
    def climbStairs(self, n) -> int:  
      	pre = cur = 1
        for i in range(2,n+1):
            cur,pre = pre+cur,cur
        return cur
      
```

